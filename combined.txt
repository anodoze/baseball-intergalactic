// === claude prompt.md ===
# This Project: Baseball Intergalactic

## Core Concept

A fantasy baseball simulator with RPG mechanics. Players are fictional with attributes that weight probabilistic outcomes. Emphasis on min-maxing, weird builds, and emergent narratives.

### Key Design Principles
Probabilistic, not deterministic: Skill weights dice, never guarantees
Allow unrealistic extremes: operate on anime rules - peak players can run faster, jump higher, and hit harder than any human person.
Power/Grace as narrative foils: bruisers vs finesse wizards
Bullshit space is large: Any team can win any game - even if it's unlikely

### Terminology
Manager: Human player of the sim
Player: Fictional in-game athlete

### Specific Common Design Patterns
Outcome weights are stored in structs and then modified by circumstance and player attributes. After modifiers are applied, the die is rolled and that result determines the next step.

## Architecture

### Game State Hierarchy
- Game: Owns teams, rosters, active defensive assignments (via indices), and scoreboard. Runs innings.
- Inning: Handles both top and bottom half. Runs PAs until 3 outs, twice.
- PlateAppearance: Manages balls/strikes/contact loop. Returns outcome (Strikeout/Walk/Out/Safe).
- Contact: Generates contact properties, determines fielding attempt, resolves outcome.
- Display: class handles output to console

### Team & Game State
Teams have 28 players: 14 position players (9 active + 5 bench), 14 pitchers (5 starters, 4 relievers, 5 bench).

RosterPosition (persistent): Player's default org chart slot. Set during draft/signing, rarely changes except for management decisions or career-ending injuries.

FieldPosition (ephemeral game state): Where the player is currently playing. Tracked via indices in Game, discarded at end of game. Allows mid-game substitutions without mutating the roster.

BattingLineupOrder: Array of indices into Team.PositionPlayers. Persists between games, manager can reorder.

Players are position-agnostic - all have batting, pitching, fielding, and baserunning attributes. A position player *can* pitch in a pinch and vice versa.

## Pitch Model
- Zone-based pitching (1-9 in-zone, 11-14 out-of-zone)
- Weighted ball/strike swinging/strike looking/contact outcomes based on pitch type and zone
- Pitch model where pitcher chooses zone, throws pitch, and outcomes are determined by opposed player attributes setting weights for a final dice roll
- PA loop that tracks balls, strikes, and contact

What we're working on: 
- Pitch types with different characteristics
- Pitcher choices depending on pitch mix, attributes, and opposing batter

Down the road: 
- pitcher and catcher interaction, esp. framing

## Field/Contact Model - bat on ball, now what? - ACTIVE PROJECT

### Contact Generation
#### Contact properties:
- Direction (1-7): Modified by batter Aim. High Aim → gaps, low Aim → fouls
- Angle (Grounder/Line/Fly/Popup): Modified by batter Form. High Form → lines/flies, low Form → grounders/popups  
- Force (Weak/Clean/Blast): Modified by batter Power. Determines ball velocity/distance

### Fielding - ACTIVE PROJECT
- Choose responsible defender based on contact properties (Direction/Angle/Force modify defender weights)
- Backup fielder determined by GetBackupFielder() - directional logic based on position
  - Infield → outfield behind them
  - Outfield → null (hit wall, auto-safe)
  - Catcher grounders → corner infielders
- FieldingAttempt contains: PrimaryFielder, SecondaryFielder?, ContactInfo
- FieldingOutcomeWeights by Angle: Foul/CaughtOut/Fielded/Bobbled/Miss
- Force modifiers apply (Weak easier to field, Blast harder)
- Contact.Simulate returns ContactOutcome: Foul/Out/Safe

What we're working on:
- Foul tips (handle in pitch logic, not fielding)
- Fielder attribute/skill modifiers on fielding outcomes
- Throw attempt logic (Arm + Precision vs distance)
- returning BIP outcomes to the PA logic to determine if it ends (on base/out) or continues (foul)
- Quality modifiers on "Fielded" outcome (clean vs scramble)
- store the state of the bases and track runners and scoring

Down the road:
- XBH
- homerun checks

## Player Attributes - baseline values are 0-1 floats and grow from there

### BODY Attributes (grow then decline over a player's career)
- Vision: ball tracking
- Awareness: game state/positioning  
- Reaction: twitch response speed
- Power: force generation (throwing/hitting distance)
- Grace: mechanical execution quality, reduces injury
- Speed: raw movement speed
- Stamina: degradation over the course of a game (mostly affects pitchers/catchers, starts to get to everyone else in extras)

### SOUL Attributes (grow over a player's career) - not currently implemented, but crucial to the roadmap
- Charisma: interaction with fans
- Esprit: interaction with teammates
- Aggression: play hungry, steal bases hit whatever comes, charge fielding opportunities, charge the mound. draws out aggression in other players
- Judgement: plays smarter, especially tempers the worse outcomes of Aggression while enhancing the good ones
- Wisdom: improves play over the course of a game (especially affects the pitcher/batter matchup)
- Superstition: how much a player is affected by Luck (in both directions)
- Grit: weather unlucky events, improve performance at low Stamina, improve performance with minor injury, improve recovery from major injury

## Player Skills (grow throughout the player's career. have an effect on their own and also leverage attributes for full effect)

### Pitching Skills
- Deception: hide the next pitch. on catchers, improves framing ability - Awareness, Wisdom
- Control: throw to the most-favorable zones for the chosen pitch - Grace
- Mechanics: extra leverage on Power and Grace into other skills - primary pitching balance lever
- Velocity: throw fast, decrease contact - Power
- Movement: increase strikes - Grace, Power
- Presence: reduce the power of hits - Power
- Stuff: induce poor-quality hit types like popups and grounders - Grace

### Batting Skills
- Discipline: avoid swinging when it's a bad idea (risk: batter is too easy to scare) - Judgement, Wisdom
- Attack: swing more when it's good (risk: might become a whiffer) - Aggression, Judgement, Wisdom
- Contact: make bat-on-ball - Vision, Reaction
- Form: convert Power into clean hits - Grace, Power
- Aim: hit to advantageous locations - Awareness, Grace
- Intimidation: scare pitcher into easier zones - Power, Aggression, Charisma

### Baserunning Skills
- Sprint: round the basepaths - Speed
- Performance: effectively makes fielders worse - Reaction, Grace
- Stealth: for stealing - Speed, Awareness

### Defense Skills
- Sense: understand the game state and make good decisions - Awareness
- Precision: throw accurately to teammates - Vision
- Arm: throw hard and fast, especially across long distances - Power
- Agility: get in range of the ball - Speed
- Acrobatics: grab a ball that's near you, whether hit or thrown (can compensate for low-precision teammates) - Reaction, Grace
- Dexterity: grab the squirreliest ground balls and tag the slipperiest baserunners - Reaction

## Roster Management - not implemented, but major design space

### Rosters
Managers draft a full team at the start of their first season (batters, pitchers, benchwarmers)
- choose from 5 options per position: 3 rookies / 1 mid-career / 1 peak per position
- One chance midseason and offseason for roster turnover
- High control over post-draft roster - it's just where you start. Lineup changes, positions swaps, all on the table.
- Medium control over long-term player attribute and skill growth
- Low control over granular in-game events
- no plans for player trading between managers

### Player growth
Players have Durability representing the state of their career (reduced at the end of every season, and by events in/out of game)
- fast-growing rookies
- peak players with high SKILL and BODY 
- aging players - BODY will decline, MIND and SKILL can still grow, if slower. 
- NATURE (BODY and MIND) is harder to grow than SKILL, you're more at the mercy of base stat rolls and have to work around player strengths and weaknesses.
- theoretical maximum career length is 20 seasons, but most players will be in the 6-10 range.

### Injury
- Players can be injured. Minor injuries impact performance, and increase the risk of major injury
- Major injuries force a player onto the bench until they recover.
rare Catastrophic injuries can end a career outright if they happen too late in a career for them to recover.

# Current State:
Basic game loop functional. One inning simulates (top half only). Contact generates, fielding resolves to Out/Safe/Foul. Many outcomes are weighted but weights are placeholders - we'll tweak after a full game can be played. No baserunning, no scoring, no display, no pitcher changes, no full 9 innings yet.

# FAQ - things I commonly need to clarify
`Players` get passed around the game by reference using indices. We are avoiding copying because they will eventually need to store persistent effects
`Fielded` means the fielder has the ball and needs to throw to make an out
// === Game.cs ===
using Basedball;

public class Game
{
	public Team HomeTeam { get; }
	public Team AwayTeam { get; }
	private Dictionary<FieldPosition, int> _homeDefenseIndices;
	private Dictionary<FieldPosition, int> _awayDefenseIndices;
	private int _homePitcherIndex;
	private int _awayPitcherIndex;
	private Random _random;

	public Game(Team home, Team away, Random random)
	{
		HomeTeam = home;
		AwayTeam = away;
		_random = random;
		_homeDefenseIndices = InitializeDefenseIndices(home);
		_awayDefenseIndices = InitializeDefenseIndices(away);
		_homePitcherIndex = 0; // todo: choose starters based on stamina and ingame day
		_awayPitcherIndex = 0;
	}

	public void Play()
	{
		// TODO: full 9 innings with allowance for extras
		var inning = new Inning(
			AwayTeam,
			HomeTeam,
			_awayDefenseIndices,
			_awayPitcherIndex,
			_homeDefenseIndices,
			_homePitcherIndex,
			_random
		);
		inning.Play();
	}

	private Dictionary<FieldPosition, int> InitializeDefenseIndices(Team team)
	{
		var indices = new Dictionary<FieldPosition, int>();

		for (int i = 0; i < 8; i++)
		{
			var fieldPos = RosterToFieldPosition(team.PositionPlayers[i].RosterPosition);
			indices[fieldPos] = i;
		}

		return indices;
	}

	private static FieldPosition RosterToFieldPosition(RosterPosition roster)
	{
		return roster switch
		{
			RosterPosition.Catcher => FieldPosition.Catcher,
			RosterPosition.FirstBase => FieldPosition.FirstBase,
			RosterPosition.SecondBase => FieldPosition.SecondBase,
			RosterPosition.ThirdBase => FieldPosition.ThirdBase,
			RosterPosition.ShortStop => FieldPosition.ShortStop,
			RosterPosition.LeftField => FieldPosition.LeftField,
			RosterPosition.CenterField => FieldPosition.CenterField,
			RosterPosition.RightField => FieldPosition.RightField,
			_ => throw new ArgumentException($"No field position for {roster}"),
		};
	}
}

// === Inning.cs ===
using Basedball;

public class Inning
{
	private Team _awayTeam;
	private Team _homeTeam;
	private Random _random;

	private Dictionary<FieldPosition, int> _awayDefenseIndices;
	private int _awayPitcherIndex;
	private Dictionary<FieldPosition, int> _homeDefenseIndices;
	private int _homePitcherIndex;

	private Dictionary<Base, int> _runners;

	public Inning(
		Team away,
		Team home,
		Dictionary<FieldPosition, int> awayDefense,
		int awayPitcher,
		Dictionary<FieldPosition, int> homeDefense,
		int homePitcher,
		Random random
	)
	{
		_awayTeam = away;
		_homeTeam = home;
		_awayDefenseIndices = awayDefense;
		_awayPitcherIndex = awayPitcher;
		_homeDefenseIndices = homeDefense;
		_homePitcherIndex = homePitcher;
		_random = random;
		_runners = new Dictionary<Base, int>();
	}

	public void Play()
	{
		PlayHalf(_awayTeam, _homeTeam, _homeDefenseIndices, _homePitcherIndex); // top
		PlayHalf(_homeTeam, _awayTeam, _awayDefenseIndices, _awayPitcherIndex); // bottom
	}

	private void PlayHalf(
		Team batting,
		Team fielding,
		Dictionary<FieldPosition, int> defenseIndices,
		int pitcherIndex
	)
	{
		var pitcher = fielding.Pitchers[pitcherIndex];
		Display.HalfInningStart(batting.Name, pitcher);

		int outs = 0;
		int lineupIndex = 0;
		_runners = new Dictionary<Base, int>();

		while (outs < 3)
		{
			var batterIndex = batting.BattingLineup[lineupIndex];
			var batter = batting.PositionPlayers[batterIndex];
			lineupIndex = (lineupIndex + 1) % 9;

			var paOutcome = PlateAppearance.Simulate(
				batter,
				pitcher,
				fielding,
				defenseIndices,
				_runners,
				_random
			);

			outs += paOutcome.Outs;

			if (paOutcome.PAType != PAResultType.Strikeout && !paOutcome.IsFoul)
			{
				_runners = paOutcome.RunnersOnBase;
				// TODO: display runs scored
				// TODO: track runs on scoreboard
			}
		}
	}
}

public enum Base
{
	First,
	Second,
	Third,
}

// === Team.CS ===
using Basedball;

public class Team
{
	public string Name { get; }
	public Player[] PositionPlayers { get; }
	public Player[] Pitchers { get; }
	public int[] BattingLineup { get; set; }

	public Team(string name, Player[] positionPlayers, Player[] pitchers)
	{
		Name = name;
		PositionPlayers = positionPlayers;
		Pitchers = pitchers;
		BattingLineup = [0, 1, 2, 3, 4, 5, 6, 7, 8];
	}
}

public static class TeamGenerator
{
	public static Team GenerateTeam(string name, Random random)
	{
		var positionPlayers = new Player[14];
		var pitchers = new Player[14];

		var positions = new[]
		{
			RosterPosition.Catcher,
			RosterPosition.FirstBase,
			RosterPosition.SecondBase,
			RosterPosition.ThirdBase,
			RosterPosition.ShortStop,
			RosterPosition.LeftField,
			RosterPosition.CenterField,
			RosterPosition.RightField,
			RosterPosition.DesignatedHitter,
		};

		for (int i = 0; i < 9; i++)
		{
			positionPlayers[i] = new Player(positions[i], random);
		}

		for (int i = 9; i < 14; i++)
		{
			positionPlayers[i] = new Player(RosterPosition.BenchBatter, random);
		}

		for (int i = 0; i < 5; i++)
		{
			pitchers[i] = new Player(RosterPosition.StartingPitcher, random);
		}

		for (int i = 5; i < 9; i++)
		{
			pitchers[i] = new Player(RosterPosition.ReliefPitcher, random);
		}

		for (int i = 9; i < 14; i++)
		{
			pitchers[i] = new Player(RosterPosition.BenchPitcher, random);
		}

		return new Team(name, positionPlayers, pitchers);
	}
}

// === Player.CS ===
using Basedball;

public class Player
{
	public string Id { get; set; }
	public string FirstName { get; set; }
	public string LastName { get; set; }
	public RosterPosition RosterPosition { get; set; }

	public float Durability { get; set; }
	public float Composure { get; set; }

	// Nature
	// BODY
	public float Vision { get; set; }
	public float Awareness { get; set; }
	public float Reaction { get; set; }
	public float Power { get; set; }
	public float Grace { get; set; }
	public float Speed { get; set; }
	public float Stamina { get; set; }

	//MIND
	public float Charisma { get; set; }
	public float Esprit { get; set; }
	public float Aggression { get; set; }
	public float Judgement { get; set; }
	public float Wisdom { get; set; }
	public float Superstition { get; set; }
	public float Grit { get; set; }

	// Skill
	// batting
	public float Discipline { get; set; }
	public float Attack { get; set; }
	public float Contact { get; set; }
	public float Form { get; set; }
	public float Aim { get; set; }
	public float Intimidation { get; set; }

	// pitching
	public float Deception { get; set; }
	public float Control { get; set; }
	public float Mechanics { get; set; }
	public float Velocity { get; set; }
	public float Movement { get; set; }
	public float Presence { get; set; }
	public float Stuff { get; set; }

	// baserunning
	public float Sprint { get; set; }
	public float Performance { get; set; }
	public float Sneak { get; set; }

	// defense
	public float Sense { get; set; }
	public float Agility { get; set; }
	public float Acrobatics { get; set; }
	public float Arm { get; set; }
	public float Dexterity { get; set; }
	public float Precision { get; set; }

	public List<PitchType> Pitches { get; set; } = [];

	public Player(RosterPosition position, Random random)
	{
		Id = Guid.NewGuid().ToString();
		FirstName = NameData.firstNames[random.Next(NameData.firstNames.Length)];
		LastName = NameData.lastNames[random.Next(NameData.lastNames.Length)];
		RosterPosition = position;

		var allPitches = Enum.GetValues<PitchType>();
		var numPitches = random.Next(1, 5);
		var shuffled = allPitches.OrderBy(x => random.Next()).Take(numPitches);
		Pitches.AddRange(shuffled);

		Durability = 100; // placeholder
		Composure = 100; // placeholder

		Vision = random.NextSingle() * 0.1f;
		Awareness = random.NextSingle() * 0.1f;
		Reaction = random.NextSingle() * 0.1f;
		Power = random.NextSingle() * 0.1f;
		Grace = random.NextSingle() * 0.1f;
		Speed = random.NextSingle() * 0.1f;
		Stamina = random.NextSingle() * 0.1f;

		Charisma = random.NextSingle() * 0.1f;
		Esprit = random.NextSingle() * 0.1f;
		Aggression = random.NextSingle() * 0.1f;
		Judgement = random.NextSingle() * 0.1f;
		Wisdom = random.NextSingle() * 0.1f;
		Superstition = random.NextSingle() * 0.1f;
		Grit = random.NextSingle() * 0.1f;

		Discipline = random.NextSingle() * 0.1f;
		Attack = random.NextSingle() * 0.1f;
		Contact = random.NextSingle() * 0.1f;
		Form = random.NextSingle() * 0.1f;
		Aim = random.NextSingle() * 0.1f;
		Intimidation = random.NextSingle() * 0.1f;

		Deception = random.NextSingle() * 0.1f;
		Mechanics = random.NextSingle() * 0.1f;
		Velocity = random.NextSingle() * 0.1f;
		Control = random.NextSingle() * 0.1f;
		Movement = random.NextSingle() * 0.1f;
		Stuff = random.NextSingle() * 0.1f;
		Presence = random.NextSingle() * 0.1f;

		Sprint = random.NextSingle() * 0.1f;
		Performance = random.NextSingle() * 0.1f;
		Sneak = random.NextSingle() * 0.1f;

		Sense = random.NextSingle() * 0.1f;
		Agility = random.NextSingle() * 0.1f;
		Acrobatics = random.NextSingle() * 0.1f;
		Arm = random.NextSingle() * 0.1f;
		Dexterity = random.NextSingle() * 0.1f;
		Precision = random.NextSingle() * 0.1f;
	}
}

public enum RosterPosition
{
	StartingPitcher,
	ReliefPitcher,
	Closer,
	Catcher,
	FirstBase,
	SecondBase,
	ThirdBase,
	ShortStop,
	LeftField,
	CenterField,
	RightField,
	DesignatedHitter,
	BenchBatter,
	BenchPitcher,
}

public enum PitchType
{
	Fastball,
	Changeup,
	Curveball,
	Slider,
}

// === PlateAppearance.cs ===
using Basedball;

public class PlateAppearance
{
	public static PAOutcome Simulate(
		Player batter,
		Player pitcher,
		Team fielding,
		Dictionary<FieldPosition, int> defenseIndices,
		Dictionary<Base, int> runners,
		Random random
	)
	{
		Display.NowBatting(batter);

		int ballCount = 0;
		int strikeCount = 0;
		PAOutcome outcome;

		while (strikeCount < 3 && ballCount < 4)
		{
			var pitchResult = Pitch.ThrowPitch(batter, pitcher, random);

			if (pitchResult.Outcome is PitchOutcome.StrikeLooking or PitchOutcome.StrikeSwinging)
			{
				strikeCount++;
				Display.Pitch(pitchResult, ballCount, strikeCount);
				if (strikeCount >= 3)
				{
					Display.Strikeout(batter);
					return new PAOutcome(paType: PAResultType.Strikeout);
				}
			}
			else if (pitchResult.Outcome is PitchOutcome.Ball)
			{
				ballCount++;
				Display.Pitch(pitchResult, ballCount, strikeCount);
				if (ballCount >= 4)
				{
					Display.Walk(batter);
					return new PAOutcome(paType: PAResultType.Walk);
				}
			}
			else if (pitchResult.Outcome is PitchOutcome.Contact)
			{
				var contactInfo = Contact.GenerateContactInfo(batter, random);
				var fieldingAttempt = Contact.PrepareFieldingAttempt(
					contactInfo,
					fielding,
					defenseIndices,
					random
				);
				outcome = Contact.ResolveFielding(
					fieldingAttempt,
					fielding,
					defenseIndices,
					runners,
					random
				);

				if (outcome.IsFoul)
				{
					if (strikeCount < 2)
						strikeCount++;
					Display.Foul(strikeCount);
				}
				else
				{
					return outcome;
				}
			}
		}
		Display.Error("Plate Appearance loop exited without resolution");
		return new PAOutcome(paType: PAResultType.SimError, outs: 0);
	}
}

public class Pitch
{
	private static readonly Dictionary<int, ZoneWeights> DefaultZoneWeights = new()
	{
		// Heart of the plate (middle-middle) - most contact
		[5] = new ZoneWeights(looking: 0.15f, contact: 0.70f, swinging: 0.15f),
		// Middle edges - good contact zones
		[2] = new ZoneWeights(looking: 0.20f, contact: 0.60f, swinging: 0.20f),
		[4] = new ZoneWeights(looking: 0.25f, contact: 0.55f, swinging: 0.20f),
		[6] = new ZoneWeights(looking: 0.25f, contact: 0.55f, swinging: 0.20f),
		[8] = new ZoneWeights(looking: 0.20f, contact: 0.60f, swinging: 0.20f),
		// Corners - harder to hit, more whiffs and looking strikes
		[1] = new ZoneWeights(looking: 0.35f, contact: 0.40f, swinging: 0.25f),
		[3] = new ZoneWeights(looking: 0.30f, contact: 0.45f, swinging: 0.25f),
		[7] = new ZoneWeights(looking: 0.30f, contact: 0.45f, swinging: 0.25f),
		[9] = new ZoneWeights(looking: 0.35f, contact: 0.40f, swinging: 0.25f),
		// Chase zones - outside but tempting
		[11] = new ZoneWeights(ball: 0.40f, contact: 0.35f, swinging: 0.25f), // High
		[12] = new ZoneWeights(ball: 0.50f, contact: 0.30f, swinging: 0.20f), // Away (RHH vs RHP)
		[13] = new ZoneWeights(ball: 0.45f, contact: 0.35f, swinging: 0.20f), // Low
		[14] = new ZoneWeights(ball: 0.55f, contact: 0.25f, swinging: 0.20f), // Inside (RHH vs RHP)
	};

	public static PitchResult ThrowPitch(Player pitcher, Player batter, Random random)
	{
		// select pitch
		// balk?
		// select zone
		// int cornerPick = new[] { 1, 3, 7, 9 }[_random.Next(4)];
		int zonePick = new[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14 }[random.Next(13)];
		var zoneWeights = DefaultZoneWeights[zonePick];
		var batterWeights = new ZoneWeights(
			batter.Discipline * 2.0f,
			-batter.Attack,
			batter.Contact,
			batter.Attack * 0.5f
		);

		var pitcherWeights = new ZoneWeights(
			-(pitcher.Movement * 0.5f),
			pitcher.Movement,
			-pitcher.Velocity,
			pitcher.Movement
		);

		zoneWeights += batterWeights;
		zoneWeights += pitcherWeights;

		if (zonePick is 11 or 12 or 13 or 14)
		{
			zoneWeights.Looking = 0;
		}
		else
		{
			zoneWeights.Ball = 0;
		}

		var outcome = zoneWeights.RollDice(random);
		return new PitchResult { Outcome = outcome, Zone = zonePick };
	}
	// todo: add foul tips at some point?
	// runners may attempt to steal!
	// notice?
	// throw them out?
}

public enum PitchOutcome
{
	StrikeLooking,
	StrikeSwinging,
	Ball,
	Contact,
	Balk,
}

public struct PitchResult
{
	public PitchOutcome Outcome { get; init; }
	public int Zone { get; init; }
	// public PitchType PitchType { get; init; }
	// pitch speed
}

//RUNNERS
// judgement: try to advance?
// speed: advancement success
// performance: lowers defense effectiveness, can sneak under what would otherwise be a tagout

// === Contact.cs ===
using Basedball;

public class Contact
{
	public static ContactInfo GenerateContactInfo(Player batter, Random random)
	{
		var directionWeights = FieldDefaults.DefaultDirectionWeights[Handedness.Righty];
		var batterDirectionWeights = new DirectionWeights(
			leftLine: -(batter.Aim - 0.5f) * 1.5f,
			leftGap: (batter.Aim - 0.5f) * 2.4f,
			leftCenter: (batter.Aim - 0.5f) * 1.0f,
			center: 0f,
			rightCenter: (batter.Aim - 0.5f) * 1.0f,
			rightGap: (batter.Aim - 0.5f) * 2.4f,
			rightLine: -(batter.Aim - 0.5f) * 1.5f
		);
		directionWeights += batterDirectionWeights;
		var direction = directionWeights.RollDice(random);

		var angleWeights = FieldDefaults.DefaultAngleWeights[direction];
		var batterAngleWeights = new AngleWeights(
			ground: -(batter.Form - 0.5f) * 1.8f,
			line: (batter.Form - 0.5f) * 2.4f,
			fly: (batter.Form - 0.5f) * 1.6f,
			popup: -(batter.Form - 0.5f) * 1.2f
		);
		angleWeights += batterAngleWeights;
		var angle = angleWeights.RollDice(random);

		var forceWeights = FieldDefaults.DefaultForceWeights[direction];
		var batterForceWeights = new ForceWeights(
			weak: -(batter.Power - 0.5f) * 2.0f,
			clean: (batter.Power - 0.5f) * 1.0f,
			blast: (batter.Power - 0.5f) * 2.4f
		);
		forceWeights += batterForceWeights;
		var force = forceWeights.RollDice(random);

		return new ContactInfo(direction, angle, force);
	}

	public static PAOutcome ResolveFielding(
		FieldingAttempt fieldingAttempt,
		Team fielding,
		Dictionary<FieldPosition, int> defenseIndices,
		Dictionary<Base, int> runners,
		Random random
	)
	{
		var primaryOutcome = RollFieldingOutcome(fieldingAttempt, random);

		// TODO: Display fielding flavor based on primaryOutcome here eventually

		var paOutcome = primaryOutcome switch
		{
			FieldingOutcome.Foul => new PAOutcome(isFoul: true),
			FieldingOutcome.CaughtOut => new PAOutcome(
				outs: 1,
				runners: runners,
				paType: PAResultType.BallInPlay
			),
			FieldingOutcome.Fielded => ResolveThrow(
				fieldingAttempt,
				fielding,
				defenseIndices,
				runners,
				random
			),
			FieldingOutcome.Miss when fieldingAttempt.SecondaryFielder != null =>
				ResolveSecondaryFielder(fieldingAttempt, fielding, defenseIndices, runners, random),
			FieldingOutcome.Miss => new PAOutcome(
				runners: runners,
				paType: PAResultType.BallInPlay
			),
			_ => throw new InvalidOperationException(
				$"Unexpected fielding outcome: {primaryOutcome}"
			),
		};

		return paOutcome;
	}

	private static FieldingOutcome RollFieldingOutcome(FieldingAttempt attempt, Random random)
	{
		var weights = FieldDefaults.DefaultFieldingWeights[attempt.Contact.Angle];
		var forceModifier = FieldDefaults.ForceFieldingModifiers[attempt.Contact.Force];
		weights += forceModifier;
		if (
			attempt.Contact.Direction != Direction.LeftLine
			&& attempt.Contact.Direction != Direction.RightLine
		)
		{
			weights = new FieldingOutcomeWeights(
				foul: 0f,
				caughtOut: weights.CaughtOut,
				fielded: weights.Fielded,
				miss: weights.Miss
			);
		}
		// TODO: check fielder attribute modifiers (Agility, Acrobatics, etc.)
		return weights.RollDice(random);
	}

	public static FieldingAttempt PrepareFieldingAttempt(
		ContactInfo contact,
		Team fielders,
		Dictionary<FieldPosition, int> defenseIndices,
		Random random
	)
	{
		var defenderWeights = FieldDefaults.DefaultDefenderWeights[contact.Direction];

		var angleModifier = contact.Angle switch
		{
			Angle.Ground => new DefenderWeights(
				pitcher: 0.05f,
				catcher: 0.15f,
				firstBase: 0.10f,
				secondBase: 0.10f,
				thirdBase: 0.10f,
				shortStop: 0.10f,
				leftField: -0.25f,
				centerField: -0.25f,
				rightField: -0.25f
			),
			Angle.Line => new DefenderWeights(),
			Angle.Fly => new DefenderWeights(
				pitcher: -0.10f,
				catcher: -0.15f,
				firstBase: -0.05f,
				secondBase: -0.05f,
				thirdBase: -0.05f,
				shortStop: -0.05f,
				leftField: 0.20f,
				centerField: 0.20f,
				rightField: 0.20f
			),
			Angle.Popup => new DefenderWeights(
				pitcher: 0.05f,
				catcher: 0.20f,
				firstBase: 0.05f,
				secondBase: 0.05f,
				thirdBase: 0.05f,
				shortStop: 0.05f,
				leftField: -0.15f,
				centerField: -0.15f,
				rightField: -0.15f
			),
			_ => new DefenderWeights(),
		};

		var forceModifier = contact.Force switch
		{
			Force.Weak => new DefenderWeights(
				pitcher: 0.10f,
				catcher: 0.15f,
				firstBase: 0.05f,
				secondBase: 0.05f,
				thirdBase: 0.05f,
				shortStop: 0.05f,
				leftField: -0.15f,
				centerField: -0.15f,
				rightField: -0.15f
			),
			Force.Clean => new DefenderWeights(),
			Force.Blast => new DefenderWeights(
				pitcher: -0.10f,
				catcher: -0.15f,
				firstBase: -0.05f,
				secondBase: -0.05f,
				thirdBase: -0.05f,
				shortStop: -0.05f,
				leftField: 0.15f,
				centerField: 0.15f,
				rightField: 0.15f
			),
			_ => new DefenderWeights(),
		};

		defenderWeights += angleModifier + forceModifier;

		var primaryPosition = defenderWeights.RollDice(random);
		var secondaryPosition = GetBackupFielder(primaryPosition, contact.Direction, contact.Angle);

		var primaryFielder = GetFielderAtPosition(fielders, defenseIndices, primaryPosition);
		var secondaryFielder = secondaryPosition.HasValue
			? GetFielderAtPosition(fielders, defenseIndices, secondaryPosition.Value)
			: null;

		if (primaryFielder == null)
			throw new InvalidOperationException($"No fielder found at {primaryPosition}");

		return new FieldingAttempt
		{
			PrimaryFielder = primaryFielder,
			SecondaryFielder = secondaryFielder,
			Contact = contact,
		};
	}

	private static PAOutcome ResolveThrow(
		FieldingAttempt attempt,
		Team fielding,
		Dictionary<FieldPosition, int> defenseIndices,
		Dictionary<Base, int> runners,
		Random random
	)
	{
		// TODO: PLACEHOLDER - implement actual throw mechanics based on distance, Arm, Precision
		var isInfield =
			attempt.PrimaryFielder.RosterPosition
			is RosterPosition.Catcher
				or RosterPosition.FirstBase
				or RosterPosition.SecondBase
				or RosterPosition.ThirdBase
				or RosterPosition.ShortStop;

		return isInfield
			? new PAOutcome(outs: 1, runners: runners, paType: PAResultType.BallInPlay)
			: new PAOutcome(runners: runners, paType: PAResultType.BallInPlay);
	}

	private static PAOutcome ResolveSecondaryFielder(
		FieldingAttempt attempt,
		Team fielding,
		Dictionary<FieldPosition, int> defenseIndices,
		Dictionary<Base, int> runners,
		Random random
	)
	{
		var weights = FieldDefaults.DefaultFieldingWeights[attempt.Contact.Angle];

		// Backup is scrambling - much harder to field cleanly
		var backupModifier = new FieldingOutcomeWeights(
			foul: 0f, // no fouls on secondary attempt - do we need to formally clamp this?
			caughtOut: -0.3f,
			fielded: -0.5f,
			miss: 0.4f
		);
		weights += backupModifier;

		var fieldingOutcome = weights.RollDice(random);

		var paOutcome = fieldingOutcome switch
		{
			FieldingOutcome.CaughtOut => new PAOutcome(
				outs: 1,
				runners: runners,
				paType: PAResultType.BallInPlay
			),
			FieldingOutcome.Fielded => new PAOutcome(
				runners: runners,
				paType: PAResultType.BallInPlay
			), // needs bases
			_ => new PAOutcome(paType: PAResultType.BallInPlay), // missed, needs bases
		};

		return paOutcome;
	}

	public static FieldPosition? GetBackupFielder(
		FieldPosition primary,
		Direction direction,
		Angle angle
	)
	{
		if (
			primary
			is FieldPosition.LeftField
				or FieldPosition.CenterField
				or FieldPosition.RightField
		)
			return null;

		if (primary == FieldPosition.Catcher)
		{
			if (angle == Angle.Ground)
			{
				return direction switch
				{
					Direction.LeftLine or Direction.LeftGap or Direction.LeftCenter =>
						FieldPosition.ThirdBase,
					Direction.Center => FieldPosition.FirstBase, // TODO: add choice when there are baserunners
					Direction.RightCenter or Direction.RightGap or Direction.RightLine =>
						FieldPosition.FirstBase,
					_ => null,
				};
			}
			return null;
		}

		return (primary, direction) switch
		{
			(FieldPosition.ThirdBase, _) => FieldPosition.LeftField,
			(FieldPosition.ShortStop, Direction.LeftLine or Direction.LeftGap) =>
				FieldPosition.LeftField,
			(FieldPosition.ShortStop, Direction.LeftCenter or Direction.Center) =>
				FieldPosition.CenterField,
			(FieldPosition.SecondBase, Direction.RightLine or Direction.RightGap) =>
				FieldPosition.RightField,
			(FieldPosition.SecondBase, Direction.RightCenter or Direction.Center) =>
				FieldPosition.CenterField,
			(FieldPosition.FirstBase, _) => FieldPosition.RightField,
			(FieldPosition.Pitcher, _) => FieldPosition.CenterField,
			_ => null,
		};
	}

	private static Player GetFielderAtPosition(
		Team team,
		Dictionary<FieldPosition, int> defenseIndices,
		FieldPosition position
	)
	{
		if (position == FieldPosition.Pitcher)
			return team.Pitchers[0]; // TODO: choose pitcher index at Game start and pass in

		if (!defenseIndices.TryGetValue(position, out int index))
			throw new InvalidOperationException($"No fielder assigned to {position}");

		return team.PositionPlayers[index];
	}
}

public struct ContactInfo
{
	public Direction Direction { get; init; }
	public Angle Angle { get; init; }
	public Force Force { get; init; }

	public ContactInfo(Direction direction, Angle angle, Force force)
	{
		Direction = direction;
		Angle = angle;
		Force = force;
	}
}

public struct FieldingAttempt
{
	public Player PrimaryFielder { get; init; }
	public Player? SecondaryFielder { get; init; }
	public ContactInfo Contact { get; init; }
}

public struct PAOutcome
{
	public bool IsFoul { get; init; } // we need to check this first, so that basestate does not get modified in case of fouls
	public Dictionary<Base, int> RunnersOnBase { get; init; } // null if foul
	public int RunsScored { get; init; }
	public int Outs { get; init; } // 0, 1, or 2 (double plays)
	public PAResultType PAType { get; init; }

	public PAOutcome(
		bool isFoul = false,
		Dictionary<Base, int>? runners = null,
		int runs = 0,
		int outs = 0,
		PAResultType paType = PAResultType.BallInPlay
	)
	{
		IsFoul = isFoul;
		RunnersOnBase = runners ?? new Dictionary<Base, int>();
		RunsScored = runs;
		Outs = outs;
		PAType = paType;
	}
}

public enum PAResultType
{
	Strikeout,
	Walk,
	BallInPlay,
	SimError,
}

